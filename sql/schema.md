# Required Database Schema for SaiNo1Code Website

Please execute the following SQL commands in your Supabase SQL Editor to create the necessary tables for the application to function correctly.

## 1. Profiles Table

This table stores user-specific public data and is linked to the `auth.users` table. It's used for user information, subscription management, and payment integration.

**Important:** This table is required for user management, subscription tracking, and payment integration.

**Schema:** Enhanced version with subscription status, billing information, and payment provider support.

```sql
-- Create a table for public user profiles
CREATE TABLE IF NOT EXISTS profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  avatar_url TEXT,
  
  -- Subscription Information
  subscription_status TEXT DEFAULT 'inactive' CHECK (subscription_status IN ('inactive', 'active', 'trial', 'cancelled')),
  plan_name TEXT DEFAULT 'Free',
  billing_cycle TEXT CHECK (billing_cycle IN ('monthly', 'yearly', NULL)),
  subscription_start_date TIMESTAMPTZ,
  subscription_end_date TIMESTAMPTZ,
  
  -- Stripe Integration (if needed in future)
  stripe_customer_id TEXT,
  
  -- Razorpay Integration (existing)
  razorpay_customer_id TEXT,
  razorpay_subscription_id TEXT,
  razorpay_plan_id TEXT,
  razorpay_current_period_start TIMESTAMPTZ,
  razorpay_current_period_end TIMESTAMPTZ,
  last_payment_id TEXT,
  last_payment_amount NUMERIC,
  last_payment_date TIMESTAMPTZ,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for faster lookups
CREATE INDEX IF NOT EXISTS idx_profiles_subscription_status ON profiles(subscription_status);
CREATE INDEX IF NOT EXISTS idx_profiles_plan_name ON profiles(plan_name);
CREATE INDEX IF NOT EXISTS idx_profiles_stripe_customer_id ON profiles(stripe_customer_id);
CREATE INDEX IF NOT EXISTS idx_razorpay_subscription_id ON profiles(razorpay_subscription_id);
CREATE INDEX IF NOT EXISTS idx_razorpay_customer_id ON profiles(razorpay_customer_id);

-- Set up Row Level Security (RLS)
-- See https://supabase.com/docs/guides/auth/row-level-security
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Create indexes for performance
CREATE INDEX idx_profiles_subscription_status ON profiles(subscription_status);
CREATE INDEX idx_profiles_plan_name ON profiles(plan_name);
CREATE INDEX idx_profiles_stripe_customer_id ON profiles(stripe_customer_id);

-- Enable Row Level Security
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- RLS Policies for profiles
CREATE POLICY "Users can view own profile"
  ON profiles FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
  ON profiles FOR UPDATE
  USING (auth.uid() = id);

CREATE POLICY "Users can insert own profile"
  ON profiles FOR INSERT
  WITH CHECK (auth.uid() = id);

-- This trigger automatically creates a profile entry when a new user signs up.
-- See https://supabase.com/docs/guides/auth/managing-user-data#using-triggers
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, subscription_status, plan_name)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email),
    'inactive',
    'Free'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

```

## 2. API Keys Table

This table stores API keys generated by users to activate the VS Code extension. For security, the keys are hashed in the database.

**Important:** This table is required for the API Key Management feature and VS Code OAuth authentication.

**Schema:** Enhanced version with activity tracking and soft delete capability.

```sql
-- Create a table for user API keys (NEW SCHEMA - 7 columns)
CREATE TABLE api_keys (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  hashed_key TEXT NOT NULL,
  key_prefix TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  last_used_at TIMESTAMPTZ,
  is_active BOOLEAN DEFAULT TRUE
);

-- Create indexes for performance
CREATE INDEX idx_api_keys_user_id ON api_keys(user_id);
CREATE INDEX idx_api_keys_hashed_key ON api_keys(hashed_key);
CREATE INDEX idx_api_keys_is_active ON api_keys(is_active);

-- Enable Row Level Security
ALTER TABLE api_keys ENABLE ROW LEVEL SECURITY;

-- Users can view their own API keys
CREATE POLICY "Users can view own API keys"
  ON api_keys FOR SELECT
  USING (auth.uid() = user_id);

-- Users can insert their own API keys
CREATE POLICY "Users can insert own API keys"
  ON api_keys FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Users can update their own API keys
CREATE POLICY "Users can update own API keys"
  ON api_keys FOR UPDATE
  USING (auth.uid() = user_id);

-- Users can delete their own API keys
CREATE POLICY "Users can delete own API keys"
  ON api_keys FOR DELETE
  USING (auth.uid() = user_id);

```

## 3. Custom Provider Keys Table

This table stores encrypted API keys for third-party services (e.g., OpenAI, Groq) that users provide.

**Important:** This requires the `pgsodium` extension to be enabled in your Supabase project for encryption.

```sql
-- Create a table for user-provided custom API keys
create table custom_provider_keys (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users not null,
  provider_name text not null,
  encrypted_key bytea not null, -- Nonce is combined with the key by pgsodium
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, provider_name)
);

-- Enable Row Level Security
alter table custom_provider_keys
  enable row level security;

-- Users can view their own custom provider key entries (but not the key itself).
create policy "Users can view their own custom keys." on custom_provider_keys
  for select using (auth.uid() = user_id);

-- Users can insert their own custom keys.
create policy "Users can insert their own custom keys." on custom_provider_keys
  for insert with check (auth.uid() = user_id);

-- Users can delete their own custom keys.
create policy "Users can delete their own custom keys." on custom_provider_keys
  for delete using (auth.uid() = user_id);
```

## 4. Encryption Function for Custom Keys

This PostgreSQL function is called via RPC from the application to securely encrypt and store custom provider API keys.

**Important:** This function requires the `pgsodium` extension to be enabled. You must also create a server key for `pgsodium` to use for encryption. You can do this by running `select pgsodium.create_key('aead-ietf', 'custom_keys_encryption_key');` once in your SQL editor.

```sql
-- Function to securely upsert (insert or update) a custom provider API key
create or replace function upsert_custom_provider_key(
    p_provider_name text,
    p_api_key text
)
returns void as $$
declare
    v_user_id uuid := auth.uid();
    v_key_id uuid;
    v_encrypted_key bytea;
begin
    -- Get the key_id for the encryption key
    select id into v_key_id from pgsodium.key where name = 'custom_keys_encryption_key';
    if v_key_id is null then
        raise exception 'Encryption key not found. Please run `select pgsodium.create_key(''aead-ietf'', ''custom_keys_encryption_key'');`';
    end if;

    -- Encrypt the API key using non-deterministic (random nonce) encryption.
    -- The nonce is handled internally by this function and prepended to the ciphertext.
    v_encrypted_key := pgsodium.crypto_aead_ietf_encrypt(
        p_api_key::bytea,
        ''::bytea, -- additional data (optional)
        v_key_id
    );

    -- Upsert the key into the table
    insert into custom_provider_keys (user_id, provider_name, encrypted_key)
    values (v_user_id, p_provider_name, v_encrypted_key)
    on conflict (user_id, provider_name)
    do update set
        encrypted_key = excluded.encrypted_key;
end;
$$ language plpgsql security definer;

-- Grant execute permission to authenticated users
grant execute on function upsert_custom_provider_key(text, text) to authenticated;

```

## 5. Transactional API Key Regeneration

This function ensures that regenerating a primary API key is an atomic operation. It deletes the old key and inserts the new one within a single transaction, preventing a state where a user could be left without a key if the insertion fails.

```sql
## 5. Transactional API Key Regeneration

This function ensures that regenerating a primary API key is an atomic operation. It deactivates old keys (soft delete) and inserts the new one within a single transaction.

**New Behavior:** Uses soft delete (`is_active = FALSE`) instead of hard delete to maintain history.

```sql
-- Function to transactionally regenerate a primary API key
CREATE OR REPLACE FUNCTION transactional_regenerate_api_key(
  p_key_prefix TEXT,
  p_hashed_key TEXT
)
RETURNS VOID AS $$
BEGIN
  -- Deactivate all existing keys (soft delete)
  UPDATE api_keys
  SET is_active = FALSE
  WHERE user_id = auth.uid();
  
  -- Insert new key
  INSERT INTO api_keys (user_id, hashed_key, key_prefix, is_active)
  VALUES (auth.uid(), p_hashed_key, p_key_prefix, TRUE);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION transactional_regenerate_api_key(text, text) TO authenticated;
```
```