# Required Database Schema for SaiNo1Code Website

Please execute the following SQL commands in your Supabase SQL Editor to create the necessary tables for the application to function correctly.

## 1. Profiles Table

This table stores user-specific public data and is linked to the `auth.users` table. It's used to store Razorpay customer and subscription information along with other public profile data.

**Important:** This table is required for the Razorpay payment integration to work correctly.

```sql
-- Create a table for public user profiles
create table profiles (
  id uuid references auth.users not null primary key,
  updated_at timestamp with time zone,
  full_name text,
  avatar_url text,
  -- Razorpay customer and subscription info
  razorpay_customer_id text,
  razorpay_subscription_id text,
  razorpay_plan_id text,
  razorpay_current_period_start timestamp with time zone,
  razorpay_current_period_end timestamp with time zone,
  subscription_status text default 'inactive',
  last_payment_id text,
  last_payment_amount numeric,
  last_payment_date timestamp with time zone,
  plan_name text
);

-- Create indexes for faster lookups
create index idx_razorpay_subscription_id on profiles(razorpay_subscription_id);
create index idx_razorpay_customer_id on profiles(razorpay_customer_id);
create index idx_subscription_status on profiles(subscription_status);

-- Set up Row Level Security (RLS)
-- See https://supabase.com/docs/guides/auth/row-level-security
alter table profiles
  enable row level security;

create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can insert their own profile." on profiles
  for insert with check (auth.uid() = id);

create policy "Users can update own profile." on profiles
  for update using (auth.uid() = id);

-- This trigger automatically creates a profile entry when a new user signs up.
-- See https://supabase.com/docs/guides/auth/managing-user-data#using-triggers
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

```

## 2. API Keys Table

This table stores API keys generated by users to activate the VS Code extension. For security, the keys are hashed in the database.

**Important:** This table is required for the API Key Management feature.

```sql
-- Create a table for user API keys
create table api_keys (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users not null,
  key_prefix text not null,
  hashed_key text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable Row Level Security
alter table api_keys
  enable row level security;

-- Users can view their own API key prefixes.
create policy "Users can view their own API key prefixes." on api_keys
  for select using (auth.uid() = user_id);

-- Users can insert their own API keys.
create policy "Users can insert their own API keys." on api_keys
  for insert with check (auth.uid() = user_id);

-- Users can delete (revoke) their own API keys.
create policy "Users can revoke their own API keys." on api_keys
  for delete using (auth.uid() = user_id);

```

## 3. Custom Provider Keys Table

This table stores encrypted API keys for third-party services (e.g., OpenAI, Groq) that users provide.

**Important:** This requires the `pgsodium` extension to be enabled in your Supabase project for encryption.

```sql
-- Create a table for user-provided custom API keys
create table custom_provider_keys (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users not null,
  provider_name text not null,
  encrypted_key bytea not null, -- Nonce is combined with the key by pgsodium
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, provider_name)
);

-- Enable Row Level Security
alter table custom_provider_keys
  enable row level security;

-- Users can view their own custom provider key entries (but not the key itself).
create policy "Users can view their own custom keys." on custom_provider_keys
  for select using (auth.uid() = user_id);

-- Users can insert their own custom keys.
create policy "Users can insert their own custom keys." on custom_provider_keys
  for insert with check (auth.uid() = user_id);

-- Users can delete their own custom keys.
create policy "Users can delete their own custom keys." on custom_provider_keys
  for delete using (auth.uid() = user_id);
```

## 4. Encryption Function for Custom Keys

This PostgreSQL function is called via RPC from the application to securely encrypt and store custom provider API keys.

**Important:** This function requires the `pgsodium` extension to be enabled. You must also create a server key for `pgsodium` to use for encryption. You can do this by running `select pgsodium.create_key('aead-ietf', 'custom_keys_encryption_key');` once in your SQL editor.

```sql
-- Function to securely upsert (insert or update) a custom provider API key
create or replace function upsert_custom_provider_key(
    p_provider_name text,
    p_api_key text
)
returns void as $$
declare
    v_user_id uuid := auth.uid();
    v_key_id uuid;
    v_encrypted_key bytea;
begin
    -- Get the key_id for the encryption key
    select id into v_key_id from pgsodium.key where name = 'custom_keys_encryption_key';
    if v_key_id is null then
        raise exception 'Encryption key not found. Please run `select pgsodium.create_key(''aead-ietf'', ''custom_keys_encryption_key'');`';
    end if;

    -- Encrypt the API key using non-deterministic (random nonce) encryption.
    -- The nonce is handled internally by this function and prepended to the ciphertext.
    v_encrypted_key := pgsodium.crypto_aead_ietf_encrypt(
        p_api_key::bytea,
        ''::bytea, -- additional data (optional)
        v_key_id
    );

    -- Upsert the key into the table
    insert into custom_provider_keys (user_id, provider_name, encrypted_key)
    values (v_user_id, p_provider_name, v_encrypted_key)
    on conflict (user_id, provider_name)
    do update set
        encrypted_key = excluded.encrypted_key;
end;
$$ language plpgsql security definer;

-- Grant execute permission to authenticated users
grant execute on function upsert_custom_provider_key(text, text) to authenticated;

```

## 5. Transactional API Key Regeneration

This function ensures that regenerating a primary API key is an atomic operation. It deletes the old key and inserts the new one within a single transaction, preventing a state where a user could be left without a key if the insertion fails.

```sql
-- Function to transactionally regenerate a primary API key
create or replace function transactional_regenerate_api_key(
    p_key_prefix text,
    p_hashed_key text
)
returns void as $$
declare
    v_user_id uuid := auth.uid();
begin
    -- Delete any existing key for the user
    delete from public.api_keys where user_id = v_user_id;

    -- Insert the new key
    insert into public.api_keys(user_id, key_prefix, hashed_key)
    values (v_user_id, p_key_prefix, p_hashed_key);
end;
$$ language plpgsql security definer;

-- Grant execute permission to authenticated users
grant execute on function transactional_regenerate_api_key(text, text) to authenticated;
```